import { createElement, useReducer, useMemo, createContext, useContext } from 'react';
import { Portal } from 'reakit/Portal';
import shortid from 'shortid';

/**
 * Picks the notification from the front of the queue and renders it
 */
function QueuedNotifications(_ref) {
  var {
    state
  } = _ref;
  var notification = state.queue[0];
  return notification ? createElement(notification.component, {
    destroy: notification.destroy
  }) : null;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

var INITIAL_STATE = {
  queue: []
};
function NotificationsReducer() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : INITIAL_STATE;
  var action = arguments.length > 1 ? arguments[1] : undefined;

  switch (action.type) {
    case "CREATE":
      {
        var notification = {
          id: action.id,
          component: action.component,
          destroy: action.destroy
        };
        return _objectSpread2({}, state, {
          queue: [...state.queue, notification]
        });
      }

    case "DESTROY":
      {
        return _objectSpread2({}, state, {
          queue: state.queue.filter(notification => notification.id !== action.id)
        });
      }

    case "POP":
      {
        var [_, ...rest] = state.queue;
        return _objectSpread2({}, state, {
          queue: rest
        });
      }

    default:
      return state;
  }
}

function useNotificationsState() {
  var [state, dispatch] = useReducer(NotificationsReducer, INITIAL_STATE);
  var actions = useMemo(() => ({
    create: component => {
      var id = shortid.generate();

      var destroy = () => dispatch({
        type: "DESTROY",
        id
      });

      dispatch({
        type: "CREATE",
        id,
        component,
        destroy
      });
      return {
        destroy
      };
    },
    destroy: id => {
      dispatch({
        type: "DESTROY",
        id
      });
    },
    pop: () => {
      dispatch({
        type: "POP"
      });
    }
  }), []);
  return {
    state,
    dispatch,
    actions
  };
}

var createNotificationsProvider = NotificationContext => (_ref) => {
  var {
    children,
    render = QueuedNotifications
  } = _ref;
  var state = useNotificationsState();
  return createElement(NotificationContext.Provider, {
    value: state.actions
  }, children, createElement(Portal, null, createElement(render, state)));
};

var DEFAULT_CONTEXT = {
  create: () => {
    throw new Error("create cannot be used outside of a NotificationProvider");
  },
  destroy: () => {
    throw new Error("destroy cannot be used outside of a NotificationProvider");
  },
  pop: () => {
    throw new Error("pop cannot be used outside of a NotificationProvider");
  }
};
function createScopedNotificationManager() {
  var notificationContext = createContext(DEFAULT_CONTEXT);
  return {
    NotificationsProvider: createNotificationsProvider(notificationContext),
    useNotificationManager: () => useContext(notificationContext)
  };
}

/**
 * Shows all notifications in the queue
 */
function StackedNotifications(_ref) {
  var {
    state
  } = _ref;
  return state.queue.map(notification => createElement(notification.component, {
    key: notification.id,
    destroy: notification.destroy
  }));
}

var {
  NotificationsProvider,
  useNotificationManager
} = createScopedNotificationManager();

export { NotificationsProvider, QueuedNotifications, StackedNotifications, createScopedNotificationManager, useNotificationManager };
