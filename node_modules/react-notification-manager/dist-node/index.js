'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var React = require('react');
var Portal = require('reakit/Portal');
var shortid = _interopDefault(require('shortid'));

/**
 * Picks the notification from the front of the queue and renders it
 */
function QueuedNotifications({
  state
}) {
  const notification = state.queue[0];
  return notification ? React.createElement(notification.component, {
    destroy: notification.destroy
  }) : null;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(source, true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(source).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

const INITIAL_STATE = {
  queue: []
};
function NotificationsReducer(state = INITIAL_STATE, action) {
  switch (action.type) {
    case "CREATE":
      {
        const notification = {
          id: action.id,
          component: action.component,
          destroy: action.destroy
        };
        return _objectSpread2({}, state, {
          queue: [...state.queue, notification]
        });
      }

    case "DESTROY":
      {
        return _objectSpread2({}, state, {
          queue: state.queue.filter(notification => notification.id !== action.id)
        });
      }

    case "POP":
      {
        const [_, ...rest] = state.queue;
        return _objectSpread2({}, state, {
          queue: rest
        });
      }

    default:
      return state;
  }
}

function useNotificationsState() {
  const [state, dispatch] = React.useReducer(NotificationsReducer, INITIAL_STATE);
  const actions = React.useMemo(() => ({
    create: component => {
      const id = shortid.generate();

      const destroy = () => dispatch({
        type: "DESTROY",
        id
      });

      dispatch({
        type: "CREATE",
        id,
        component,
        destroy
      });
      return {
        destroy
      };
    },
    destroy: id => {
      dispatch({
        type: "DESTROY",
        id
      });
    },
    pop: () => {
      dispatch({
        type: "POP"
      });
    }
  }), []);
  return {
    state,
    dispatch,
    actions
  };
}

const createNotificationsProvider = NotificationContext => ({
  children,
  render = QueuedNotifications
}) => {
  const state = useNotificationsState();
  return React.createElement(NotificationContext.Provider, {
    value: state.actions
  }, children, React.createElement(Portal.Portal, null, React.createElement(render, state)));
};

const DEFAULT_CONTEXT = {
  create: () => {
    throw new Error("create cannot be used outside of a NotificationProvider");
  },
  destroy: () => {
    throw new Error("destroy cannot be used outside of a NotificationProvider");
  },
  pop: () => {
    throw new Error("pop cannot be used outside of a NotificationProvider");
  }
};
function createScopedNotificationManager() {
  const notificationContext = React.createContext(DEFAULT_CONTEXT);
  return {
    NotificationsProvider: createNotificationsProvider(notificationContext),
    useNotificationManager: () => React.useContext(notificationContext)
  };
}

/**
 * Shows all notifications in the queue
 */
function StackedNotifications({
  state
}) {
  return state.queue.map(notification => React.createElement(notification.component, {
    key: notification.id,
    destroy: notification.destroy
  }));
}

const {
  NotificationsProvider,
  useNotificationManager
} = createScopedNotificationManager();

exports.NotificationsProvider = NotificationsProvider;
exports.QueuedNotifications = QueuedNotifications;
exports.StackedNotifications = StackedNotifications;
exports.createScopedNotificationManager = createScopedNotificationManager;
exports.useNotificationManager = useNotificationManager;
